\documentclass {report}
\usepackage[usenames]{color}
\usepackage{tikz}
\usepackage{colortbl}
\usepackage{ulem}
\usepackage[pdfborder=0 0 0,colorlinks,linkcolor=black]{hyperref}
\usepackage{verbatim}
\usepackage[utf8]{inputenc}
\usepackage[T1, T2A]{fontenc}
\usepackage[english,russian]{babel}
\usepackage{indentfirst}
\usepackage{listings}
\usepackage{titling}
\usepackage{geometry}
\geometry{pdftex, a4paper}
\geometry{left=2.5cm, right=2.5cm, top = 2cm}
\usepackage{caption}
\DeclareCaptionFont{white}{\color{white}}
\definecolor{mycol}{rgb}{0.98,0.92,0.9}
\definecolor{mycol1}{rgb}{0.8,0.2,0.2}
\DeclareCaptionFormat{listing}{\colorbox{mycol1}{\parbox{\textwidth}{#1#2#3}}}
\captionsetup[lstlisting]{format=listing}
\date{16.05.2018}
\posttitle{\par версия первая и единственная\end{center}}
\title{{\bfseries Динамическая библиотека libPendulum.dll}}
\begin{document}
\lstset{%
language=C++,            
basicstyle=\small\ttfamily, 
numbers=left,       
numberstyle=\tiny,       
stepnumber=1,           
numbersep=5pt,            
backgroundcolor=\color{mycol},
showspaces=false,  
showstringspaces=false,  
showtabs=false,     
keywordstyle=\bfseries\color{green!40!black},
identifierstyle=\color{blue},
stringstyle=\color{orange},
frame=single,    
tabsize=2,         
captionpos=t,       
breaklines=true,         
breakatwhitespace=false,
escapeinside={\%*}{*)}   
}
\lstset{
  literate={а}{{\selectfont\char224}}1
           {б}{{\selectfont\char225}}1
           {в}{{\selectfont\char226}}1
           {г}{{\selectfont\char227}}1
           {д}{{\selectfont\char228}}1
           {е}{{\selectfont\char229}}1
           {ё}{{\"e}}1
           {ж}{{\selectfont\char230}}1
           {з}{{\selectfont\char231}}1
           {и}{{\selectfont\char232}}1
           {й}{{\selectfont\char233}}1
           {к}{{\selectfont\char234}}1
           {л}{{\selectfont\char235}}1
           {м}{{\selectfont\char236}}1
           {н}{{\selectfont\char237}}1
           {о}{{\selectfont\char238}}1
           {п}{{\selectfont\char239}}1
           {р}{{\selectfont\char240}}1
           {с}{{\selectfont\char241}}1
           {т}{{\selectfont\char242}}1
           {у}{{\selectfont\char243}}1
           {ф}{{\selectfont\char244}}1
           {х}{{\selectfont\char245}}1
           {ц}{{\selectfont\char246}}1
           {ч}{{\selectfont\char247}}1
           {ш}{{\selectfont\char248}}1
           {щ}{{\selectfont\char249}}1
           {ъ}{{\selectfont\char250}}1
           {ы}{{\selectfont\char251}}1
           {ь}{{\selectfont\char252}}1
           {э}{{\selectfont\char253}}1
           {ю}{{\selectfont\char254}}1
           {я}{{\selectfont\char255}}1
           {А}{{\selectfont\char192}}1
           {Б}{{\selectfont\char193}}1
           {В}{{\selectfont\char194}}1
           {Г}{{\selectfont\char195}}1
           {Д}{{\selectfont\char196}}1
           {Е}{{\selectfont\char197}}1
           {Ё}{{\"E}}1
           {Ж}{{\selectfont\char198}}1
           {З}{{\selectfont\char199}}1
           {И}{{\selectfont\char200}}1
           {Й}{{\selectfont\char201}}1
           {К}{{\selectfont\char202}}1
           {Л}{{\selectfont\char203}}1
           {М}{{\selectfont\char204}}1
           {Н}{{\selectfont\char205}}1
           {О}{{\selectfont\char206}}1
           {П}{{\selectfont\char207}}1
           {Р}{{\selectfont\char208}}1
           {С}{{\selectfont\char209}}1
           {Т}{{\selectfont\char210}}1
           {У}{{\selectfont\char211}}1
           {Ф}{{\selectfont\char212}}1
           {Х}{{\selectfont\char213}}1
           {Ц}{{\selectfont\char214}}1
           {Ч}{{\selectfont\char215}}1
           {Ш}{{\selectfont\char216}}1
           {Щ}{{\selectfont\char217}}1
           {Ъ}{{\selectfont\char218}}1
           {Ы}{{\selectfont\char219}}1
           {Ь}{{\selectfont\char220}}1
           {Э}{{\selectfont\char221}}1
           {Ю}{{\selectfont\char222}}1
           {Я}{{\selectfont\char223}}1
}
\begin{titlepage}
	\centering
	{\scshape\Large Документация по проекту\par}
	\vspace{1.5cm}
	{\huge\bfseries Динамическая библиотека libPendulum.dll \par}
	\vspace{2cm}
	{\itshape Программирование, механика, 1 курс\par}
	\vfill
	{\large \today\par}
\end{titlepage}
\tableofcontents
\newpage
Динамическая библиотека libPendulum.dll содержит в себе классы моделей маятников, а так же некоторые необходимые константы, функции и т.д. Все физические величины далее приведены в СИ, если указано другое. Пока что здесь всего три более-менне полноценных модели: простой математический маятник, физический маятник, и маятник, на который действует вязкое трение. Кроме того, метод для нахождения координат маятника Фуко. Автор библиотеки надеется расширить ее. Когда-нибудь...
\newline
\section{Структура библиотеки}
{\centering {\bfseries Составляющие} (на данный момент, еще можно добавить пользовательские модули):}
\begin{center}
\begin{tikzpicture}
\path (0, 0) node(x) {Pendulum.h}
(0,-2) node(p) {Пользовательский модуль (?)}
(4.5,-2) node(y) {Pendulum.cpp}
(-7.5, -2) node(z) {SMP.cpp}
(-4.5,-2) node(w) {PHYP.cpp }
(7.5,-2) node(u) {PWF.cpp};
\draw [->, mycol1, thick] (x) -- (p);
\draw [->, mycol1, thick] (x) -- (y);
\draw [->, mycol1, thick] (x) -- (z);
\draw [->, mycol1, thick] (x) -- (w);
\draw [->, mycol1, thick] (x) -- (u);
\end{tikzpicture}
\end{center}
{\centering \bfseries Внутренние зависимости:}
\begin{center}
\begin{tikzpicture}
\path (0, 0) node(x)  {Pendulum.cpp <=> базовый класс Pendulum}
(-5, -1) node(z) {SMP.cpp <=> класс Simple\_Math\_Pendulum}
(-5,-2) node(w) {PHYP.cpp <=> класс Ph\_Pendulum}
(5,-1) node(u) {PWF.cpp <=> класс Pendulum\_W\_Friction};
\draw [->, mycol1, thick] (x) -- (z);
\draw [->, mycol1, thick] (x) -- (u);
\draw [->, mycol1, thick] (z) -- (w);
\end{tikzpicture}
\end{center}
Чтобы подключить библиотеку, достаточно заголовочного файла Pendulum.h и, собственно, библиотеки.
\section{Модули} 
\subsection{Pendulum.cpp и класс Pendulum}
Содержит описание методов базового класса Pendulum: функции ввода-вывода стандартных характеристик --- начальных координаты и скорости, длины подвеса и массы (и вывод, и ввод с проверкой на корректность), угла отклонения (фазы) и амплитуды (только вывод). bool-поле existence определяет, существует маятник или нет. Маятник может перестать существовать в результате некорректного ввода данных. 
\begin{lstlisting}[caption=Pendulum.cpp]
#include "Pendulum.h"
#include <cmath>
using namespace std;
void Pendulum::put_x0(double d) { 	//меняет начальную координату на переданное значение и переопредеяляет остальные характеристики
	x0 = d;
	def();
}
void Pendulum::put_v0(double d) { 	//меняет начальную скорость на переданное значение и переопредеяляет остальные характеристики 
	v0 = d;
	def();
}
void Pendulum::put_m(double d) {   //меняет массу на переданное значение, если оно корректное
	try {
		if (d <= 0) throw "Масса маятника должна быть положительным числом\n";
		m = d;
		def();	//переопределяет остальные характеристики
	}
	catch (const char* s) {
		cerr << s;
	}
}
void Pendulum::put_l(double d) {   //меняет длину на переданное значение, если оно корректное
	try {
		if (d <= 0) throw "Длина маятника должна быть положительным числом\n";
		l = d;
		def();	//переопределяет остальные характеристики
	}
	catch (const char* s) {
		cerr << s;
	}
}
double Pendulum::get_x0() { //возвращает начальную координату
	return x0;
}
double Pendulum::get_v0() { //возвращает начальную скорость
	return v0;
}
double Pendulum::get_m() { //возвращает массу
	return m;
}
double Pendulum::get_l() { //возвращает длину
	return l;
}
double Pendulum::get_a() {  //возвращает начальную фазу
	return a;
}
double Pendulum::get_A() {  //возвращает амплитуду
	return A;
}
\end{lstlisting}
Класс Pendulum и Pendulum.cpp необходимы для остальных трех существующих ``моделей''. Pendulum включает в себя виртуальный метод \texttt{void def()}, который определяет характеристики ``модели'' на основании начальных данных. Для каждой существующей модели \texttt{def()} определен по-разному.
\subsection{Простой математический маятник. Класс Simple\_Math\_Pendulum и SMP.cpp}
Зависит от Pendulum.cpp, т.к. Simple\_Math\_Pendulum является наследником Pendulum. Кроме полей базового класса добавляются частота \texttt{(double w}) и период \texttt{(double T)}, которые определяютя \texttt{def()}, а так же методы \texttt{double get\_w()} и \texttt{double get\_T()} соответственно. 
\begin{lstlisting}
double SimpleMathPendulum::get_w(){
	return w;
}
double SimpleMathPendulum::get_T(){
	return T;
}
\end{lstlisting}
\newpage
У класса два конструктора.
\begin{lstlisting}[caption = Так определится простой математический маятник по умолчанию]
SimpleMathPendulum::SimpleMathPendulum() {
	x0 = 1;
	v0 = 0;
	m = 0.1;
	l = 5;
	def();
}
\end{lstlisting}
Почему какие-то заранее заданные значения? Чтобы не возникало неопределенности. Поэтому маятник ``по умолчанию'' --- это маятник массой 100 грамм, с длиной подвеса 5 метров, начальной координатой 1 м и нулевой начальной скоростью. 
\begin{lstlisting}[caption = Так можно считать маятник из файлового потока]
SimpleMathPendulum::SimpleMathPendulum(ifstream & f1) {
	try {
		f1 >> x0;
		f1 >> m;
		f1 >> l;
		f1 >> v0;
		if (m <= 0) throw "Масса маятника должна быть положительным числом \n";
		if (l <= 0) throw "Длина маятника должна быть положительным числом \n";
		def();
	}
	catch (const char* s) {
		cout << s;
		existence = false;
	}
	catch (...) {
		cout << "Неверный формат исходных данных \n";
		existence = false;
	}
}
\end{lstlisting}
\begin{lstlisting}[caption = Определение SMP. Метод def()]
void SimpleMathPendulum::def() {
	T = 2 * pi*pow(l / g, 0.5);	//период
	w = pow(g / l, 0.5); //частота
	A = pow((x0*x0 + (v0 / w)*(v0 / w)), 0.5);	//амплитуда
	if (v0 == 0)
		a = pi / 2;
	else							//фаза (угол начального отклонения)				
		a = atan(x0*w / v0);
}
\end{lstlisting}
И, наконец, метод \texttt{double x (double t)}, находящий координату x маятника в момент времени t.
\begin{lstlisting}[caption = Уравнение движения. Метод x(t).]
double SimpleMathPendulum::x(double t) {
	if (existence)
		return A*sin(w*t + a);
	cerr << "Маятник не существует \n";
	return NULL;
}
\end{lstlisting}
В Simple\_Math\_Pendulum есть метод \texttt{void Fou(double \&, double \&, double, double)}, который возвращает координаты x и y маятника Фуко с теми же начальными данными, что и у данного простого математического. //хотя можно было бы создать отдельный класс(-наследник?) маятник Фуко. \\
Метод принимает в себя переменные, в которые нужно записать значения x и y, момент времени t и географическую широту (в радианах).
\begin{lstlisting}[caption = Координаты маятника Фуко]
void SimpleMathPendulum::Fou(double &x, double &y, double t, double f) {
	if (existence) {
		double p = 0; double tt = 0;
		double w1 = pow(w*w + pow(o*sin(f), 2), 0.5);
		tt = o*sin(f)*t;
		double i, j;
		if (x0) {
			i = atan((w1*cos(tt)) / (v0 / x0 + o*sin(f)*sin(tt)));
			if (sin(i))
				j = x0 / sin(i);
			else j = 0;
		}
		else {
			i = 0;
			j = v0 / (w1*cos(tt));
		}
		p = j*sin(w1*t+i);
		x = p*cos(tt);
		y = p*sin(tt);
	}
	else {
		x = y = 0;
		cout << "Маятник не существует \n";
	}
}
\end{lstlisting}
\subsection{Маятник с вязким трением. Класс Pendulum\_W\_Friction и PWP.cpp}
Так же, как и предыдущий класс, является наследником Pendulum. Новые поля --- динамическая вязкость k (в СИ --- Па*с), указатель на функцию xt. Возвращает k --- \texttt{double get\_k()}, а принимает --- \texttt{void put\_k(double)}.
\begin{lstlisting}[caption=Конструкторы Pendulum\_W\_Friction]
PendulumWFrict::PendulumWFrict() { //тот же самый маятник ``по умолчанию'', что и у Simple_Math_Pendulum
	x0 = 1;
	v0 = 0;
	m = 0.1;
	l = 5;
	k = 0;
	def();
}
PendulumWFrict::PendulumWFrict(ifstream & f1) { //Ничего принципиально не поменялось
	try {
		f1 >> x0;
		f1 >> m;
		f1 >> l;
		f1 >> v0;
		f1 >> k;
		if (m <= 0) throw "Масса маятника должна быть положительным числом\n";
		if (l <= 0) throw "Длина маятника должна быть положительным числом\n";
		if (k < 0) throw "Вязкость должна быть неотрицательным числом\n";
		def();
	}
	catch (const char* s) {
		existence = false;
		cerr << s;
	}
	catch (...) {
		cerr << "Неверный формат исходных данных \n";
		existence = false;
	}
}
\end{lstlisting}
\begin{lstlisting}[caption=Определение PWF. Метод def()]
void PendulumWFrict::def() {
	w0 = pow(g / l, 0.5);
	A = pow((x0*x0 + (v0 / w0)*(v0 / w0)), 0.5);
	if (v0 == 0)
		a = pi / 2;
	else
		a = atan(x0*w0 / v0);
	c = k / (2 * m);
	if (m*g*sin(a) <= k*v0) {
		xt = NULL;
		v0 = 0;
	}
	else {
		if (w0 > c)
			xt = x1;
		if (w0 == c)
			xt = x2;
		if (w0 < c)
			xt = x3;
	}
}
\end{lstlisting}
Так как решение уравнения движения маятника с вязким трением зависит от величин динамической вязкости и ``начальной'' частоты, три возможных варианта реализованы отдельными функциями x1, x2 и x3:
\begin{lstlisting}
double x1(double t, double c, double v0, double w0, double x0) {
	double A;
	double w = pow(w0*w0 - c*c, 0.5);
	A = pow((x0*x0 + pow((v0 + c*x0)/(w),2)), 0.5);
	double a;
	if (A == 0)
		a = 0;
	else
		a = asin(x0/A);
	return A*exp(-c*t)*sin(w*t + a);
}
double x2(double t, double c, double v0, double w0, double x0) {

	double a1 = c + pow(c*c - w0*w0, 0.5);
	double a2 = c - pow(c*c - w0*w0, 0.5);
	double C2 = (v0 + a1*x0) / (a1 - a2);
	double C1 = x0 - C2;
	return C1*exp(-a1*t) + C2*exp(-a2*t);

}
double x3(double t, double c, double v0, double w0, double x0) {
	double C1 = x0*c + v0;
	double C2 = x0;
	return (C1*t + C2)*exp(-c*t);
}
\end{lstlisting}
Какую функцию использовать решает сам метод \texttt{def()}, изменить это извне нельзя (или все-таки можно?). \\
Тогда так будет выглядеть метод, возвращающий координату x маятника с вязким трением:
\begin{lstlisting}
double PendulumWFrict::x(double t) {
	if (existence) {
		if (xt == NULL) return x0;
		return xt(t, c, v0, w0, x0);
	}
	cout << "Маятник не существует \n";
	return NULL;
}
\end{lstlisting}
У затухающих колебаний, которые описывает первый случай (x1), амплитуда зависит от времени:
\begin{lstlisting}
double PendulumWFrict::get_A(double t = 0) {
	return  A*exp(-c*t);
}
\end{lstlisting} 
А вот методы для редактирования и получения динамической вязкости. Совершенно анологично с предыдущими методами...
\begin{lstlisting}
void PendulumWFrict::put_k(double d) {
	try {
		if(d<0) throw "Вязкость должна быть неотрицательным числом\n";
		k = d;
		def();
	}
	catch (const char* s) {
		cerr << s;
	}
}
double PendulumWFrict::get_k() {
	return k;
}
\end{lstlisting}
\subsection{Физический маятник. Класс Ph\_Pendulum и PHYP.cpp}
Если заменить длину подвеса приведенной длиной, уравнение физического маятника будет совпадать с уравнением математического. Поэтому эта модель реализована как наследник Simple\_Math\_Pendulum --- простого математического маятника. Что здесь нового?\\
Новые поля --- форма f, ``радиус'' формы r, момент импульса J, а так же приведенная длина L.
Как эти поля редактировать и получать:
\begin{lstlisting}
void PhPendulum::put_r(double d) {
	try {
		if(d<=0) throw "Радиус тела должна быть положительным числом \n";
		r = d;
		def();
	}
	catch (string s) {
		cerr << s;
	}
}
double PhPendulum::get_r() {
	return r;
}
double PhPendulum::get_J() {
	return J;
}
form PhPendulum::get_form() {
	return f;
}
\end{lstlisting}
У этого физического маятника существует только четыре возможных формы: куб, шар, диск и цилиндр. За ``радиус'' берем половину стороны куба, радиус шара, малый радиус диска, радиус цилиндра. Если же форма неизвестная, то считается, что физический маятник - математический.\\
Функция (не метод), записывающая форму:
\begin{lstlisting}[caption = Для файлового ввода]
void getform(form& f, ifstream &f1) {
	string s;
	try {
		f1 >> s;
		if (s == "шар") f = ball;
		if (s == "куб") f = cube;
		if (s == "цилиндр") f = cilinder;
		if (s == "диск") f = disk;
		if (s != "шар" && s != "куб" && s != "цилиндр" && s != "диск") throw "Неопознанная форма: " + s + '\n';
	}
	catch (string s) {
		cerr << s;
		f = none;
	}
	catch (...) {
		cerr << "Неверный формат исходных данных\n";
		f = none;
	}

}
\end{lstlisting}
\begin{lstlisting}[caption = Метод]
void PendulumWFrict::put_k(double d) {
	try {
		if(d<0) throw "Вязкость должна быть неотрицательным числом\n";
		k = d;
		def();
	}
	catch (const char* s) {
		cerr << s;
	}
}
\end{lstlisting}
Конструкторы физического маятника:
\begin{lstlisting}[caption = Все тот же маятник ``по умолчанию'']
PhPendulum::PhPendulum() {
	f = none;
	r = 0;
}
\end{lstlisting}
\begin{lstlisting}[caption=Физический маятник конструируется из файлового потока]
PhPendulum::PhPendulum(ifstream & f1) {
	try {
		f1 >> x0;
		f1 >> m;
		f1 >> l;
		f1 >> v0;
		getform(f, f1);
		f1 >> r;
		if (r <= 0) throw "Радиус тела должна быть положительным числом \n";
		if (m <= 0) throw "Масса маятника должна быть положительным числом \n";
		if (l <= 0) throw "Длина маятника должна быть положительным числом \n";
		if (f == none)
			SimpleMathPendulum::def();
		else
			def();
	}
	catch (const char* s) {
		existence = false;
		cerr << s;
	}
	catch (...) {
		existence = false;
		cerr << "Неверный формат исходных данных \n";
	}
}
\end{lstlisting}
Наконец, так определен \texttt{def()} для Ph\_Pendulum:
\begin{lstlisting}
void PhPendulum::def() {
	if (f == ball) {
		J = 0.4*m*r*r;
	}
	if (f == cube) {
		J = 2 * m*r*r / 3;
	}
	if (f == cilinder) {
		J = m*r*r / 2;
	}
	if (f == disk) {
		J = m*r*r / 4; //вычислили момент инерции в зависимости от формы
	}
	L = l + r + J / ((l + r)*m); //вычислили приведенную длину
	T = 2 * pi*pow(L / g, 0.5);	//теперь это математический маятник
	w = pow(g / L, 0.5);
	A = pow((x0*x0 + (v0 / w)*(v0 / w)), 0.5);
	if (v0 == 0)
		a = pi / 2;
	else
		a = atan(x0*w / v0);
}
\end{lstlisting}
Функция \texttt{double x(double t)} родителя Ph\_Pendulum --- Simple\_MAth\_Pendulum возвращает координату центра качания данного физического маятника.
\end{document}
